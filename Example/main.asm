; ======================================================================
; Полный пример программы для демонстрации функционала компилятора
; ======================================================================
JUMP START
; ===== Секция данных =====
DATA_START:
    .ASCIIZ "Hello, World!\n"     ; Строковая константа с завершающим нулем
    .SPACE 16                     ; Резервирование 16 байт памяти (инициализировано нулями)
    .BYTE 255                     ; Запись 1-байтового значения
    .WORD 123456789               ; Запись 4-байтового значения в формате Little Endian

; ===== Начало основной программы =====
START:
    NOP                           ; Нет операции

    ; --- Арифметические операции и логические инструкции ---
    LOADI R0, 10                  ; Загрузка числа 10 в R0
    LOADI R1, 20                  ; Загрузка числа 20 в R1
    ADD   R2, R0, R1              ; Сложение: R2 = R0 + R1
    SUB   R3, R1, R0              ; Вычитание: R3 = R1 - R0
    MUL   R4, R0, R1              ; Умножение: R4 = R0 * R1
    DIV   R5, R1, R0              ; Деление: R5 = R1 / R0
    AND   R20, R0, R1             ; Побитовое И: R20 = R0 AND R1
    OR    R21, R0, R1             ; Побитовое ИЛИ:  R21 = R0 OR R1
    XOR   R22, R0, R1             ; Побитовое XOR: R22 = R0 XOR R1
    NOT   R19, R2                 ; Побитовое НЕ: R19 = NOT R2
    SHL   R23, R0, 2              ; Побитовый сдвиг влево: R23 = R0 << 2
    SHR   R24, R1, 1              ; Побитовый сдвиг вправо: R24 = R1 >> 1

    ; --- Демонстрация псевдоинструкции MOV с MOD ---
    ; Вычисление остатка от деления: 22 MOD 7
    LOADI R6, 22                  ; R6 = 22
    LOADI R7, 7                   ; R7 = 7
    MOV   R8, R6 MOD R7           ; Расширяется в:
                                  ;    DIV  R30, R6, R7
                                  ;    MUL  R31, R30, R7
                                  ;    SUB  R8, R6, R31

    ; --- Работа с адресными выражениями и памятью ---
    LOAD  R9, [100]               ; Загрузка значения из памяти по адресу 100
    STORE R1, [200]               ; Сохранение содержимого R1 по адресу 200

    ; --- Пример цикла с условным переходом ---
    LOADI R10, 5                 ; Инициализация счетчика цикла (R10 = 5)
LOOP:
    PRINT R10                   ; Вывод текущего значения R10
    LOADI R2, 1                 ; Загрузка единицы для декремента
    SUB   R10, R10, R2          ; Декремент: R10 = R10 - 1
    CMP   R10, 0                ; Сравнение R10 с 0
    IF NE, LOOP                 ; Если R10 не равен 0, переход к метке LOOP

    ; --- Работа со стеком ---
    PUSH R2                     ; Сохранение значения R2 в стек
    POP  R11                    ; Извлечение из стека в R11

    ; --- Ввод/вывод ---
    INPUT R20                   ; Чтение значения с клавиатуры в R20
    PRINTS DATA_START           ; Вывод строки, начинающейся с DATA_START

    ; --- Файловые операции ---
    LOADI R16, 1                ; Режим открытия файла (пример)
    LOADI R17, 2                ; Дополнительный параметр
    OPEN  R12, R16, R17          ; Открытие файла, результат (дескриптор) в R12
    READ  R14, R12, R16, R15      ; Чтение из файла (операнды – регистры)
    WRITE R12, R16, R17, R25      ; Запись в файл
    SEEK  R12, 4, 0, R18         ; Изменение позиции в файле
    CLOSE R12                   ; Закрытие файла

    ; --- Вывод списков файловой системы и переменных окружения ---
    FS_LIST DATA_START          ; Вывод списка файловой системы (начиная с DATA_START)
    ENV_LIST DATA_START         ; Вывод списка переменных окружения

    ; --- Сохранение и восстановление состояния ---
    SNAPSHOT                    ; Создание снимка состояния системы
    RESTORE                     ; Восстановление состояния

    ; --- Демонстрация вызова подпрограммы (вычисление факториала) ---
    LOADI R0, 5                 ; Число 5 для вычисления факториала
    CALL  FACTORIAL             ; Вызов подпрограммы FACTORIAL
    PRINT R1                    ; Вывод результата (факториал 5)

    BREAK                       ; Отладочная точка
    HALT                        ; Завершение выполнения программы

; ===== Подпрограмма: Вычисление факториала (рекурсивно) =====
FACTORIAL:
    CMP  R0, 1                 ; Сравнение: если R0 == 1
    IF EQ, FACT_RET            ; переход к метке FACT_RET, если равно 1
    PUSH R0                    ; Сохранение текущего значения R0
    LOADI R2, 1                ; R2 = 1
    SUB  R0, R0, R2            ; Декремент R0: R0 = R0 - 1
    CALL FACTORIAL             ; Рекурсивный вызов FACTORIAL
    POP  R0                    ; Восстановление R0
    MUL  R1, R0, R1            ; Вычисление: R1 = R0 * R1 (накапливаем результат)
    RET                        ; Возврат из подпрограммы

FACT_RET:
    LOADI R1, 1                ; Если R0 == 1, устанавливаем результат равным 1
    RET                        ; Возврат

